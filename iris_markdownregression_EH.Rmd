---
title: "Homework 2: Funky Functions"
author: "Ethan"
date: "2020-01-22"
output: html_document
---

Hello again! This time I would like to present my function that draws not only best fit line through a data set, but also illustrates why the line of best fit actually is the line of best fit.

First, instead of calling the Iris dataset from within R, we will be reading it in from a ".csv" file: 
```{r}
iris <- read.csv("iris.csv")
```

Next, we will apply some standard housekeeping to make the data easier to work with:
```{r}
names(iris) <- c("sepalL", "sepalW",  "petalL", "petalW", "species")
species <- iris$species
color <- rep("red", 150)
color[species == "setosa"] <- "purple"
color[species == "versicolor"] <- "blue"
color[species == "virginica"] <- "orange"
```

Now we will calculate the line of best fit through the data. For this example, we will be comparing Petal Length to Sepal Width:
```{r}
x <- iris$petalL
y <- iris$sepalW
fit <- lm( y ~ x )  #fitting the linear model
b <- coef( fit ) #grabbing the coefficients
int <- b[1] #intercept
slope <- b[2] #slope
slope
yhat <- slope*x + int #the fitted values
error <- yhat - y
sse <- sum(error^2)
sse
```

Now I have created a function called "lineplot()" that will allow you to plot different lines through the dataset by specifying the y-intercept and the slope. Furthermore, I have made the line of best fit values, the default arguments of the function:
```{r}
lineplot <- function(x=iris$petalL, y=iris$sepalW, cint=int, cslope=slope, ccol=color, cpch=16, cxlab="Petal Length", cylab="Sepal Width") {
		yhat <- cslope*x + cint #This calculates y vlaues on the fitted line from the given cslope and cint
		error <- yhat - y #This calculates the difference between the true y values and the y values on the fitted line
		sse <- sum(error^2) #This calculates the sse
		plot(x, y, col=ccol, pch=cpch, xlab=cxlab, ylab=cylab) #This generates the plot
		abline(cint, cslope) # drawing the regression line on the plot #This plots a line with the inputed cint and cslope values
		points(x, yhat, pch=7)  # adds the fitted points
		segments(x, y, x, yhat, col="black", lty=2 ) #Connects fitted points to the real points
		text(6,4.4, paste("SSE:", round(sse, 3))) #places text for sse
		text(6,4.25, paste("slope:", round(cslope, 3))) #places text for slope
		text(6,4.1, paste("y-int:", round(cint, 3))) #places text for y intercept
}
```

Using our "lineplot()" function, now we can actually change the slope and the y-intercept of the line going through the data and see how the sum square of error changes:
```{r}
lineplot() #This plots the line of best fit by default
lineplot(cint=3.5) #This increases the y intercept; best fit slope
lineplot(cint=3.2) #This decreases the y intercept; best fit slope
lineplot(cslope=-.2) #This decreases the slope; best fit y intercept
lineplot(cslope=-.4) #This decreases the slope even further; best fit y intercept
lineplot(cint=4, cslope=-.3) #This changes both the slope AND the y intercept 
```

# FINALE

And for my final trick, I will create a function that plots the log transformation of of any data points you give. I have the default arguments pulling from the iris dataset:
```{r}
logtransform <- function(x=iris$petalL, y=iris$sepalW, ccol=color, cpch=16) {
	x <- log(x)
	y <- log(y)
	logfit <- lm(y ~ x)
	plot(x, y, col=ccol, pch=cpch)
	abline(logfit)
}

logtransform(iris$petalW, iris$petalL)
logtransform(iris$petalL, iris$sepalL)
```

Finally, this function can be applied to any dataset. I have created a mock dataset using the matrix function to illustrate:
```{r}
m <- matrix(data=c(1:100), ncol=10, nrow=10)
m
logtransform(m[,1], m[,7])
```

And that will conclude my brief exploration into the world of funky functions.
